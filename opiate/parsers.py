#!/usr/bin/env python

import pprint
import xml.etree.ElementTree
import sys
import csv
from collections import defaultdict, OrderedDict
from itertools import chain, groupby, count

from __init__ import qafile, SAMPLE_ATTRS, STANDARD_NAMES

dump = xml.etree.ElementTree.dump

def get_attrs(elem):
    """
    Return a dict containing all attributes and attributes of child
    elements keyed by <element tag>_<attribute name>
    """

    return {elem.tag+'_'+key: val for key, val in elem.attrib.items()}

def flatten(elem, attr = None):
    """
    Recursively flatten an xml.etree.ElementTree element into a dict
    containing all of elem's attributes, as well as attributes of
    child elements keyed by <element tag>_<attribute name>.
    """

    attr = attr or {}
    attr.update(get_attrs(elem))

    children = list(elem)
    if children:
        for child in children:
            attr.update(flatten(child, attr))

    return attr

def cast(val, fun):
    """
    Return `fun(val)` or None if ValueError.
    """

    try:
        return fun(val)
    except ValueError:
        return None

def cast_numeric(val, failfun = lambda x: None):
    """
    Attempt to coerce val first into an in, then into a float. If both
    attempts fail, apply `failfun` to `val`.
    """
        
    for fun in (int, float, failfun):
        try:
            retval = fun(val)
        except ValueError:
            pass
        else:
            return retval
    
def cast_vals(d, attrs):
    """
    Apply transformations specified by each `fun` in `attrs`, a list of
    two-tuples containing (`key`, `fun`), limiting output to keys.
    """
    return {key:cast(d[key], fun) for key, fun in attrs if key in d}

def parse_sample(sample, compound_ids = None):
    """
    Return an iterator of dicts containing data for `sample`. Restrict
    to compounds with an id contained in set `compound_ids` if provided.
    """
    
    if compound_ids:
        keep = lambda d: d['COMPOUND_id'] in compound_ids
    else:
        keep = lambda d: True

    sample_data = cast_vals(get_attrs(sample), SAMPLE_ATTRS)
    for compound in sample.findall('COMPOUND'):
        compound_data = cast_vals(flatten(compound), SAMPLE_ATTRS)
        if keep(compound_data):
            compound_data.update(sample_data)
            yield compound_data

def get_rows(infile):

    qadata = qa_from_csv(qafile)    
    compound_ids = [d['qa_id'] for d in qadata.values()]

    tree = xml.etree.ElementTree.ElementTree(file=infile)
    sample_elems = tree.getiterator('SAMPLELISTDATA')[0].findall('SAMPLE')
    rows = chain.from_iterable(parse_sample(elem, compound_ids) for elem in sample_elems)

    return rows

def group_samples(infile, std_names = STANDARD_NAMES, split_desc = lambda desc: desc.split()[0]):
    """
    Parse an XML-format file and return two OrderedDict objects:
    (`standards`,`sample_groups`) where `standards` is keyed by names
    in std_names (default is `opiate.STANDARD_NAMES`) and
    `sample_groups` is a dict of groups generated by applying function
    `split_desc` to each SAMPLE_desc.
    """
    
    qadata = qa_from_csv(qafile)    
    compound_ids = [d['id'] for d in qadata.values()]

    tree = xml.etree.ElementTree.ElementTree(file=infile)
       
    samples = [list(parse_sample(elem, compound_ids)) \
                   for elem in tree.getiterator('SAMPLELISTDATA')[0].findall('SAMPLE')]

    # standards is a dict with keys defined in std_names returning a
    # list of dicts, each containing data for one compound.
    standards = OrderedDict()
    for sample_id, name in std_names:
        sample = samples.pop(0)
        assert sample[0]['SAMPLE_id'] == sample_id
        standards[name] = sample

    # the remainder of samples are now grouped by leading common
    # elements in SAMPLE_desc according to function `split_desc`.
    sample_groups = OrderedDict()
    for label, grp in groupby(samples, lambda s: split_desc(s[0]['SAMPLE_desc'])):
        sample_groups[label] = list(grp)

    return (standards, sample_groups)

def qa_from_csv(fname):

    qadata = OrderedDict()
    with open(fname, 'rU') as f:
        reader = csv.DictReader(f)
        for d in reader:
            coerced = OrderedDict((k, cast_numeric(d[k]) or d[k].strip() or None) \
                                      for k in reader.fieldnames)
            compound_id = coerced['qa_id']
            if compound_id:
                qadata[compound_id] = coerced

    return qadata
